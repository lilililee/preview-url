<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <meta http-equiv="X-UA-Compatible" content="ie=edge" />
    <title>Document</title>
  </head>
  <body>
    <script>
      // var p = new Promise(function(resolve, reject){
      //   resolve({a:1})
      //   console.log(22)
      // }).then(function(res1){
      //   console.log(res1)
      // })
      function handleReturnPromise(_this, returnPromise, index) {
        _this.origin.PromiseStatus = returnPromise.PromiseStatus
        _this.origin.PromiseValue = returnPromise.PromiseValue
        returnPromise._thenAndCatch = returnPromise._thenAndCatch.concat(_this._thenAndCatch.slice(index + 1))
        returnPromise.origin = _this
      }

      function doRejectCallback(_this) {
        _this._thenAndCatch.some(function(thenResolveFn, index) {
          if (thenResolveFn.type !== 'catch') return false
          var thenOrReturn = thenResolveFn.callback(_this.PromiseValue)
          if (thenOrReturn instanceof _Promise) {
            handleReturnPromise(_this, thenOrReturn, index)
          } else {
            _this.PromiseStatus = RESOLVED // catch 执行后状态改为 RESOLVED
            _this.PromiseValue = thenOrReturn
            _this.origin.PromiseValue = thenOrReturn
            _this._thenAndCatch = _this._thenAndCatch.slice(index + 1)
            doResolveCallback(_this) // 并且执行后续的所有 then
          }
          return true
        })
      }

      function doResolveCallback(_this) {
        console.log(_this._thenAndCatch)
        _this._thenAndCatch.some(function(thenResolveFn, index) {
          if (thenResolveFn.type !== 'then') return false
          var thenOrReturn = thenResolveFn.callback(_this.PromiseValue)
          if (thenOrReturn instanceof _Promise) {
            handleReturnPromise(_this, thenOrReturn, index)
            return true
          } else {
            _this.PromiseValue = thenOrReturn
            _this.origin.PromiseValue = thenOrReturn
          }
        })
        _this._thenAndCatch = []
      }
      var PENDING = 'pending'
      // var FULFILLED = 'fulfilled'
      var RESOLVED = 'resolved'
      var REJECTED = 'rejected'
      var count = 0
      function _Promise(fn) {
        if (this instanceof _Promise === false) {
          throw new TypeError("Please use the 'new' operator")
        }
        if (typeof fn !== 'function') {
          throw new TypeError(`_Promise resolver ${fn} is not a function`)
        }
        this.count = count++
        this.PromiseStatus = PENDING // _Promise状态
        this.PromiseValue = undefined // _Promise值
        this.origin = this // 最初调用的 _Promise ， 如果在then中return了新的 _Promise ，会根据该字段修改覆盖原先 _Promise
        this._thenAndCatch = [] // 保存 then 和 catch 传递的函数, catch运行后会把状态调整为 RESOLVED

        fn(this.resolve.bind(this), this.reject.bind(this))
        return this // 支持 then 链式调用
      }

      _Promise.prototype.then = function(thenResolveFn) {
        this._thenAndCatch.push({
          type: 'then',
          callback: thenResolveFn
        })
        if (this.PromiseStatus === RESOLVED) {
          doResolveCallback(this)
        }
        return this
      }

      _Promise.prototype.catch = function(thenResolveFn) {
        this._thenAndCatch.push({
          type: 'catch',
          callback: thenResolveFn
        })
        if (this.PromiseStatus === REJECTED) {
          doRejectCallback(this)
        }
        return this
      }

      _Promise.prototype.resolve = function(arg) {
        var _this = this
        setTimeout(function() {
          _this.PromiseStatus = RESOLVED
          _this.PromiseValue = arg

          console.log(111, _this)
          if (_this !== _this.origin) {
            _this.origin.PromiseStatus = RESOLVED
            _this.origin.PromiseValue = arg
          }
          doResolveCallback(_this)
        })
      }

      _Promise.prototype.reject = function(arg) {
        var _this = this
        setTimeout(function() {
          _this.PromiseStatus = RESOLVED
          _this.PromiseValue = arg
          if (_this !== _this.origin) {
            _this.origin.PromiseStatus = RESOLVED
            _this.origin.PromiseValue = arg
          }
          doRejectCallback(_this)
        })
      }

      _Promise.resolve = function(arg) {
        return new _Promise(function(resolve, reject) {
          resolve(arg)
        })
      }

      _Promise.reject = function(arg) {
        return new _Promise(function(resolve, reject) {
          reject(arg)
        })
      }

      _Promise.all = function(arg) {
        if (!Array.isArray(arg)) {
          throw new TypeError('You must pass an array to Promise.all().')
        }
        return new _Promise(function(resolve, reject) {
          var count = 0
          var result = []
          function doCount(res) {
            count++
            if (count === arg.length) {
              resolve(
                arg.map(function(p) {
                  return p.PromiseValue
                })
              )
            }
            return res
          }
          arg.forEach(function(p) {
            p.then(doCount)
          })
        })
      }

      _Promise.race = function(arg) {
        if (!Array.isArray(arg)) {
          throw new TypeError('You must pass an array to Promise.all().')
        }
        var p = new _Promise(function(resolve, reject) {
          var count = 0
          var result = []
          function doCount(res) {
            if (p.PromiseStatus === PENDING) {
              resolve(res)
            }
            return res

            // doCount = function(res) {
            //   return res
            // }
          }
          arg.forEach(function(p) {
            p.then(doCount)
          })
        })
        return p
      }

      p = _Promise

      var s2 = new p(function(resolve) {
        setTimeout(() => {
          resolve(2)
        }, 100)
      })
      var s1 = new p(function(resolve) {
        setTimeout(() => {
          resolve(1)
        }, 200)
      })
      var all = p.all([s1, s2])

      var race = p.race([s1, s2])
      console.log('all', all)

      a = new p((r, j) => {
        console.log('Promise start')
        r(55)
        // j(66)
      })
        .then(res => {
          console.log('fn1 res', res)
          // console.log('in fn1 this', this)
          // return new p(r => {
          //   console.log('Promise2 start')
          //   console.log(r)
          //   r(22)
          // })
        })
        .then(res => {
          console.log('fn2 res', res)
          // console.log('in fn1 this', this)
          return new p((r, j) => {
            console.log('Promise2 start')
            j(22)
          })
        })
        .catch(res => {
          console.log('fn3 res', res)
          // return new Promise((r, j) => {
          //   j(11)
          // })
          return 1111
        })
        .catch(res => {
          console.log('fn4 res', res)
          return { a: 1 }
        })
        .then(res => {
          console.log('fn5 res', res)
          return { a: 1 }
        })
      //   .then(res => {
      //     console.log('fn3 res', res)
      //     return { a: 1 }
      //   })
      console.log('a', a)

      // b = new _Promise(r => {
      //   console.log(1)
      //   r(11)
      // }).then(res => {

      //   console.log(res)
      //   console.log(this)
      //   return new Promise(r => {
      //     r(22)
      //   })
      // }).then(res => {
      //   console.log(res)
      //   return {a:1}
      // })
      // console.log('b',b)
    </script>
  </body>
</html>
